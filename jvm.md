### 查看进程号
1. netstat -anplut|grep 进程名称

### GC
#### 确定哪些对象还"活着"?
1. 引用计数算法
2. 可达性分析

#### 引用类型
1. 强引用
    只要强引用关系还存在，虚拟机就不会回收
2. 软引用
    在系统将要发生内存溢出前，会把这些对象列进回收范围之内进行二次回收。
3. 弱引用
    只能生存到下一次垃圾收集发生为止。
4. 虚引用
    目的只是为了能在这个对象被收集器回收时收到一个系统通知


#### 自我拯救
 可达性分析后发现没有与GC Roots相连接的引用链，放入Finalize()线程。在执行之前，重新与引用链上的任何一个对象建立关联，移出"即将回收"的集合。没有任何引用，直接GC。

### GC方法
1. 标记-清除算法
2. 标记-复制算法
3. 标记-整理算法


### 堆内存划分

堆内存分为年轻代，老年代。年轻代又分为Eden区和Survivor区。Survivor区由FromSpace和ToSpace组成。


### JVM堆内存参数
| 参数 | 描述 | 
| :----  | :---- | 
| -Xms | 堆内存初始大小 | 
| -Xmx | 最大堆大小 |
| -Xmn |  新生代大小|
| -Xss | 栈的大小|

### 为什么需要两个survivor区域

**最大的好处就是解决了碎片化**

刚刚新建的对象在Eden中，经历一次Minor GC，Eden中的存活对象就会被移动到第一块survivor space S0，Eden被清空；等Eden区再满了，就再触发一次Minor GC，Eden和S0中的存活对象又会被复制送入第二块survivor space S1（**这个过程非常重要，因为这种复制算法保证了S1中来自S0和Eden两部分的存活对象占用连续的内存空间，避免了碎片化的发生**）。

### 垃圾收集器

#### 新生代收集器

1. `Serial`收集器

​		采用**复制**算法的新生代收集器。

​		单线程收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直至Serial收集器收集结束为止（“Stop The World”）。

2. `ParNew`收集器

​		Serial收集器的多线程版本，它也是一个新生代收集器。除了使用多线程进行垃圾收集外，其余行为包括Serial收集器可用的所有控制参数、收集算法（复制算法）、Stop The World、对象分配规则、回收策略等与Serial收集器完全相同

​	 **除了Serial收集器外，目前只有它能和CMS收集器（Concurrent Mark Sweep）配合工作**

3. `Parallel Scavenge`

​		**并行**的**多线程**新生代收集器,使用**复制**算法。无法与CMS收集器配合使用。

#### 老年代收集器

 1. `Serial Old`收集器

    `Serial`收集器的老年代版本，一个单线程收集器，使用**“标记-整理”**（Mark-Compact）算法。

	1. `Parallel Old`收集器

​		`Parallel Scavenge`收集器的老年代版本，使用多线程和“标记-整理”算法。

3. `CMS`收集器

​		一种以**获取最短回收停顿时间**为目标的收集器，基于“标记-清除”算法实现的。

> - 初始标记（CMS initial mark）：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。
> - 并发标记（CMS concurrent mark）：进行GC Roots Tracing的过程，在整个过程中耗时最长。
> - 重新标记（CMS remark）:为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要“Stop The World”。
> - 并发清除（CMS concurrent sweep）

​	优点：

> - 支持并发收集.
> - 低停顿,因为CMS可以控制将耗时的两个stop-the-world操作保持与用户线程恰当的时机并发执行，并且能保证在短时间执行完成，这样就达到了近似并发的目的.

​	缺点：

> - CMS收集器对CPU资源非常敏感,在并发阶段虽然不会导致用户线程停顿，但是会因为占用了一部分CPU资源，如果在CPU资源不足的情况下应用会有明显的卡顿。
> - 无法处理浮动垃圾：在执行‘并发清理’步骤时，用户线程也会同时产生一部分可回收对象，但是这部分可回收对象只能在下次执行清理是才会被回收。如果在清理过程中预留给用户线程的内存不足就会出现‘Concurrent  Mode Failure’,一旦出现此错误时便会切换到SerialOld收集方式。
> - CMS清理后会产生大量的内存碎片，当有不足以提供整块连续的空间给新对象/晋升为老年代对象时又会触发FullGC。

4. `G1`收集器

   特点

> - 并行与并发:G1充分发挥多核性能，使用多CPU来缩短Stop-The-world的时间，
> - 分代收集:G1能够自己管理不同分代内已创建对象和新对象的收集。
> - 空间整合：G1从整体上来看是基于‘标记-整理’算法实现，从局部（相关的两块Region）上来看是基于‘复制’算法实现，这两种算法都不会产生内存空间碎片。
> - 可预测的停顿：它可以自定义停顿时间模型，可以指定一段时间内消耗在垃圾回收商的时间不大于预期设定值。