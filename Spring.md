### Springboot 自动装配原理

Spring Boot 通过`@EnableAutoConfiguration`开启自动装配，通过 SpringFactoriesLoader 最终加载`META-INF/spring.factories`中的自动配置类实现自动装配，自动配置类其实就是通过`@Conditional`按需加载的配置类，想要其生效必须引入`spring-boot-starter-xxx`包实现起步依赖

### @Target @Retention @Documented  @inherited注解

1. `@Target`:用于定义注解的使用位置
2. `@Retention`:用于指明修饰的注解的生存周期
   			1.   `source` : 源码级别保留，编译后即丢弃
      			1.   `CLASS`:编译级别保留，编译后的class文件中存在，在jvm运行时丢弃，这是默认值。
      			1.   `RUNTIME`:运行级别保留，编译后的class文件中存在，在jvm运行时保留，可以被反射调用。

3. `@Documented  `:指明修饰的注解，可以被例如javadoc此类的工具文档化，只负责标记，没有成员取值。
4. `@inherited`:用于标注一个父类的注解是否可以被子类继承，如果一个注解需要被其子类所继承，则在声明时直接使用@Inherited注解即可。如果没有写此注解，则无法被子类继承。

### Spring IOC 和 AOP

#### IOC   控制反转   依赖注入(DI)  同一个概念。

​			把**创建和查找依赖对象的控制权交给了容器，由容器进行注入组合对象**，所以**对象与对象之间是松散耦合**



#### AOP 面向切面编程

​			把与核心业务逻辑无关的代码全部**抽取出来**，放置到某个地方集中管理，然后在具体运行时，再由**容器动态织入这些共有代码**。

##### AOP的两种实现方式

1. jdk动态代理
2. cglib动态代理

### Spring的**循环依赖问题**

1. 构造器注入无法解决循环依赖。可以使用`@Lazy`注解实现延迟加载，@Lazy实现原理是，当实例化对象时，如果发现参数或者属性有@Lazy注解修饰，那么就不直接创建所依赖的对象了，而是使用动态代理创建一个代理类。

​			比如，类A的创建：A a=new A(B)，需要依赖对象B，发现构造函数的形参上有@Lazy注解，那么就不直接创建B了，而是使用动态代理创建了一个代理类B1，此时A跟B就不是相互依赖了，变成了A依赖一个代理类B1，B依赖A。但因为在注入依赖时，类A并没有完全的初始化完，实际上注入的是一个代理对象，只有当他首次被使用的时候才会被完全的初始化。

1. setter注入且是在单例模式下不存在循环依赖问题。
2. setter注入且是在多例模式下无法解决循环依赖。